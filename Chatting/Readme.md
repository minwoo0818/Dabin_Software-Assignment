# 1:1, 1:n 채팅 구현하기(포트를 활용!)

1. venv 가상환경을 생성 혹시 라이브러리가 다운 받아야한다면 다운 받아서 사용

2. 게임 서버를 만들 때 활용한 채팅 UDP를 참고, 인터넷 검색하여 TCP Server와 Client를 구현, 및 테스트 
    1. 서버 포트는 시작 할때 9999로 고정 세팅 
    ![alt text](<서버 소켓 생성 및 포트 bind 부분.png>)
    
    2. 클라이언트에서 socket의 connect로 연결 
    ![alt text](<클라이언트 서버 연결 connect로 임시 포트 할당.png>)
        - connect의 역할 : 운영체제에서 사용가능한 임의의 포트를 클라이언트 소켓에 할당
            1. 소켓이 생성되면 운영체제에서 식별자만 부여 포트에 연결 X
            2. 이러한 소켓에 connect를 호출해 연결할 서버의 ip와 포트를 넘겨준다. 
            3. 운영체제에서 네트워크를 검사해 현재 사용되지 않는 포트 번호를 찾아 무작위 임시 포트를 할당한다.
            4. 서버와 클라가 서로 응답을 주고 받으면 클라이언트의 임시포트와 서버의 포트가 쌍으로 연결 된다.
    3. 서버 소켓의 listen에서 클라이언트 요청을 수신 
    ![alt text](<서버에서 클라이언트 수신 후 임시 포트 할당 및 스레드 생성 부분.png>)
        - 1.에서 생성한 서버 소켓에서는 클라이언트 요청만 처리 수신 후, client_socket, _ = server_socket.accept() 'accept()' 함수로 새로운 client_socket 생성 후 할당
        - accept() 함수 내부적으로 서버의 사용 가능한 포트를 찾아옴.
        - 그 후 생성된 client_socket으로 handle하는 스레드를 생성
테스트 결과 이미지
![alt text](<서버 - 클라 메시지 송수신.png>)

3. 결론 : 과제의 목적이 포트를 직접 헨들링 하는 것이라 생각해 찾아보고 구현해 보려 하였지만, accept함수를 사용하는 것이 이상적이라고 합니다.
    - 직접 구현 단점으로 
        1. TCP/IP 패킷의 헤더를 바이트 단위로 분석하고 재구성하는 것은 오류가 발생하기 쉽습니다.
        2. socket 라이브러리가 숨겨주는 TCP 3-way 핸드셰이크, 패킷 재전송, 혼잡 제어 등은 모두 '운영체제 커널이 최적화'해서 처리하는 기능
        3. 운영체제의 네트워크 스택을 우회해야해서 Python으로는 불가능하고 C언어나 같은 더 Raw레벨의 언어나 라이브러리를 사용 해야한다.
        4. C언어로 가능한지 조사 - 하드웨어와 메모리에 더 가깝게 접근 할 수 있지만, TCP/IP 프로토콜 스택을 우회 할 수는 없고, 운영체제가 효율적이고 안전하게 관리 하기 위해 제공하는 API 이므로 사용하는것이 효율적이라고함.